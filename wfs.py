import numpy as np


def wavefront_shaping(slm, get_feedback, algorithm, fast_mode=False, post_process=True):
    """
    This function is for performing wavefront shaping experiments.
    Depending on the algorithm, this function projects "meas_count" (= algorithm.get_count) number of different wavefronts
    (generated by algorithm.get_wavefront(i)), and stores the feedback in "feedback_set"

    slm: handle to SLM

    get_feedback: function handle to feedback signal retrieving method

    algorithm: Class containing properties and methods for counting the number of measurements (algorithm.get_count)
        create wavefronts for each of the measurements (algorithm.get_wavefront()) And optionally post-process the feedback signal (algorithm.post_process(feedback_set))
        (Eg: algorithm = Fourier_dual_ref(p_steps, wavefront, kx_set, ky_set, overlap_coef))

    fast_mode: logical variable indicating if fast mode for wavefront shaping is enabled (not tested yet). By default, false.
        Eg: [WF, t, signals] = WFS(slm, feedback, algorithm,"fast_mode",true)

    :param post_process: logical variable indicating if post_processing of the signals need to be done. By default, true.
        Eg: [WF, t, signals] = WFS(slm, feedback, algorithm,"post_process",false) if false, WF and t are blank characters ''.
    :return:
    feedback_set : Feedback from the wavefront shaping experiment
    Optional (only if opt.post_process = true)
    ideal_wavefronts : Optimum wavefront at the SLM.
    if opt.post_process = false, ideal_wavefronts = ''
    t_set : Transmission if opt.post_process = false, t_set = ''
    """
    # Initialization
    meas_count = algorithm.get_count()  # total number of measurements
    feedback_set = np.zeros((meas_count, len(get_feedback())))
    if fast_mode:
        offset = 1
        t_rec = testRecordingTime(slm, get_feedback)
        pre_recording = slm.t_idle - t_rec
        post_recording = slm.t_settle + t_rec - slm.t_idle
    else:
        offset = 0
        pre_recording = slm.t_idle + slm.t_settle
        post_recording = 0

    for i in range(0, meas_count + offset):
        if i <= meas_count:
            slm.set_data(algorithm.get_wavefront(i))  # pattern is displayed on active_patch

        # These three lines together take Tsettle + Trec seconds
        slm.update(pre_recording)  # takes Tidle - Trec
        feedback = get_feedback()  # takes Trec
        slm.update(post_recording)  # takes Tsettle + Trec - Tidle

        if i >= offset:
            feedback_set[i - offset, :] = feedback
        # else, don't store the feedback since the frame is not on the SLM yet

    #        if algorithm.processRequired(i - offset):
    #            algorithm.process(feedback_set)

    if post_process:
        ideal_wavefronts, t_set, feedback_set = algorithm.post_process(feedback_set)
    else:
        print("Skipped post processing. Since you have forcefully asked to do so. " +
              "\nWFS(...,'post_process',False)")
        ideal_wavefronts = ''
        t_set = ''

    return feedback_set, ideal_wavefronts, t_set


def testRecordingTime(slm, get_feedback):
    n_vsyncs = 20
    slm.update(1)
    tic = time.time()
    slm.update(n_vsyncs)
    t_sync = (time.time() - tic) / n_vsyncs

    tic = time.time()
    for i_vsync in range(n_vsyncs):
        get_feedback()
    t_measurement = (time.time() - tic) / n_vsyncs

    t_rec = round(t_measurement / t_sync)
    return t_rec